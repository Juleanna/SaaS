SaaS-сервис мини-магазинов с личными кабинетами продавцов на Django и React

Архитектура SaaS-сервиса на Django + React
Технологический стек: Django (Python 3) + Django REST Framework, React (SPA с React Router), PostgreSQL, Redis (кэш/брокер), Celery для фоновых задач, 
Docker (или Heroku/AWS) для деплоя. Django отвечает за API и бизнес-логику, React – за клиентский интерфейс (панель продавца и лэндинг магазина). 
Например, можно использовать подход «гибридной» архитектуры: Django рендерит скелет-страницу, включающую React-купонент, который загружает данные по API saaspegasus.com. 
Аутентификация продавцов осуществляется через REST API (например, JWT-токены с django-rest-framework-simplejwt). Регистрируется пользователь (продавец), под которым 
создается магазин. База данных: Рекомендуется PostgreSQL. Структура данных может быть такой:
User (Django-пользователь) – id, email, password и т.д. Один пользователь – один продавец.
Store – id, владелец (FK→User), slug (уникальный URL магазина), название, настройки дизайна (цвета, логотип, макет) и др.
Product – id, магазин (FK→Store), название, описание, цена, изображение, наличие и т.д.
Order – id, магазин (FK→Store), данные покупателя (имя, email, телефон), сумма, статус (новый, оплачен, доставлен и т.д.), дата создания.
OrderItem – id, заказ (FK→Order), товар (FK→Product), количество, цена (на момент заказа).
StoreUserRole – id, магазин (FK→Store), пользователь (FK→User), роль (например, «администратор», «менеджер»). Альтернативно роли можно хранить через Django Groups/Permissions.
Все данные, привязанные к конкретному магазину (товары, заказы, настройки), необходимо фильтровать по Store. Можно выбрать один из подходов мультиарендности: разделённая схема 
(использовать [django-tenant-schemas/django-tenants] и отдельную PostgreSQL-схему на магазин testdriven.io django-tenant-schemas.readthedocs.io
) или общая схема (одна БД, добавить поле tenant = FK(Store) во все релевантные модели, автоматически фильтруя записи по текущему магазину
testdriven.io
). Django-tenants, например, назначает каждому арендатора схему и домен (обычно поддомен) – при запросе по этому домену все операции идут в рамках его схемы
testdriven.io
. В альтернативном «shared» варианте создаётся общий класс моделей (например, TenantOwnableModel), где менеджер моделей фильтрует данные по текущему магазину
testdriven.io
.
Модель	Ключевые поля
User	id, email, password, другие поля профиля
Store	id, владелец (FK → User), уникальный slug, название, логотип, тема и т.д.
Product	id, магазин (FK → Store), название, описание, цена, фото, наличие
Order	id, магазин (FK → Store), клиент (имя, email, телефон), сумма, статус, дата
OrderItem	id, заказ (FK → Order), товар (FK → Product), количество, цена
StoreUserRole	id, магазин (FK → Store), пользователь (FK → User), роль (админ/менеджер)

Регистрация, аутентификация и роли
Продавец регистрируется через форму (например, с помощью django-allauth), после чего получает доступ к панели своего магазина. Django User связывается с магазином как владелец. При необходимости можно расширить модель User профилем (например, добавить поля ПФР и т.д.). Авторизация — через JWT или сессионные куки (в React SPA обычно JWT). После входа продавец видит только свои данные — так же, как в демонстрационном примере связывали каждую запись с конкретным пользователем
saaspegasus.com
. Например, можно добавить в модели FK на пользователя, чтобы запросы возвращали только элементы текущего продавца
saaspegasus.com
. Внутри магазина реализуются роли пользователей: владелец-администратор (полные права) и менеджеры (ограниченный доступ). Это можно сделать через таблицу StoreUserRole или через Django Groups/Permissions. Например, владельцу присваивается роль StoreAdmin, менеджерам — StoreManager, и при проверке прав API фильтруют действия по этим ролям.
Панель управления продавца
Панель (админка) реализуется на React как SPA. После входа продавец попадает в свой «личный кабинет», где может:
Управление товарами: создавать/редактировать карточки товаров (название, описание, цену, изображения), устанавливать наличие, категории и т.д. Все операции происходят через REST API (Django REST Framework), а фронтенд отображает список продуктов, форму добавления/редактирования и т.п.
Управление заказами: просмотр новых и выполненных заказов, изменение статуса (подтвержден/отправлен), поиск по заказам. Можно реализовать фильтры и выгрузку в CSV.
Настройки магазина (лендинга): загрузка логотипа, подбор цветовой темы, добавление/удаление блоков на главную страницу. Текстовые или HTML-блоки (например, «О нас», баннеры, контакты) тоже можно редактировать. Все настройки сохраняются в модели Store (например, JSON-поле с шаблонами или отдельные поля). При сохранении цветовой схемы React меняет CSS-переменные (или подтягивает стили по ключам).
Аналитика и отчёты (опционально): базовые статистики по продажам, графики, но это выходит за рамки базовых функций.
Таким образом, панель работает как SPA-приложение: React-компоненты делают запросы к Django-API, получая данные о товарах и заказах, и обновляют интерфейс. Такой подход показан, например, в руководстве по интеграции React в Django
saaspegasus.com
.
Уникальный URL и генерация лендинга
Каждому магазину присваивается свой уникальный URL: можно реализовать через роутинг Django (например, path('<slug:store_slug>/', views.store_page)) или через React Router (в случае хостинга одного фронтенда). При запросе к mystoresite.com/magazin123 приложение получает из URL slug=magazin123, по нему через API находит магазин и его товары и показывает публичную витрину. React-лендинг магазина (корзина, форма заказа, каталог товаров) можно сделать SPA: один шаблон Django отдаёт HTML/JS, а сам вывод товаров React выполняет динамически (запрашивая /api/stores/magazin123/products). Landing-страница содержит каталог товаров (с краткой информацией и «В корзину»), информацию о магазине и форму заказа. При нажатии «Оформить» создаётся заказ в системе (через POST в API). Лендинг статически не сохраняется — он генерируется на лету по данным из БД. Цветовую тему, лого и блоки берутся из настроек Store, что позволяет «оформить» магазин по желанию продавца.
Оформление заказов
Покупатели могут оформлять заказ с регистрацией или без неё (guest checkout). Гостевой чек-аут упрощает процесс: пользователь вводит имя, телефон, адрес и завершает покупку без создания аккаунта. Это важно, так как, по данным, почти половина покупателей предпочитает оформить заказ без регистрации (быстрее и проще)
shopify.com
. Такой подход повышает конверсию, устраняя барьеры входа
shopify.com
. Если клиент всё же зарегистрируется (или уже вошёл), заказ сохраняется в его истории. При оформлении создаётся запись в Order и связанные OrderItem (кол-во, цена). Можно предусмотреть гостевые заказы с хранением email/номера телефона для связи. После оформления заказ направляется в панель продавца.
Telegram-бот
Для дополнительного канала продаж можно создать Telegram-бота, через которого покупатели тоже смогут заказывать товары. Бот может быть написан на Python (например, используя python-telegram-bot или aiogram). Логика такая: покупатель отправляет боту команду (например, /start → показывает список магазинов или запрашивает ID магазина), далее может просмотреть товары и добавить в корзину через кнопки, а затем оформить заказ. Бот использует тот же Django-бэкенд (через HTTP API) для получения списка товаров и создания заказа. После оформления бот получает подтверждение и выводит сообщение с итогами. Telegram-бот в чате выступает «продавцом-консультантом»: покупатель просто вводит запрос или выбирает из меню, а бот находит и предлагает товары, а также завершает покупку
blog.crossmint.com
. В роли примера можно привести описание Chat-бота Crossmint: «Imagine selling products through Telegram with just a simple conversation… customers type “Find me headphones under $50,” and your bot handles everything: product search, recommendations, and instant purchase completion»
blog.crossmint.com
. Таким образом, Telegram становится ещё одним интерфейсом к тому же набору товаров и заказов. Кроме того, продавцу можно отправлять уведомления о новых заказах через Telegram (бот шлёт сообщение пользователю-продавцу) на основе его зарегистрированного chat_id.
Платёжные системы
Для приёма платежей интегрируем Stripe, PayPal, ЮKassa (YooMoney). У каждой системы есть Python SDK или REST API:
Stripe: популярная платёжная система с хорошей документацией. Для разовых платежей удобно использовать Stripe Checkout или Payment Intents API. Например, в тестовом руководстве описаны три подхода: Charges API, Stripe Checkout, Payment Intents
testdriven.io
 (советуют выбирать Checkout для быстрого старта). Подключаем Stripe SDK (stripe-python), создаём сессии оплаты, обрабатываем webhooks для подтверждения платежа.
PayPal: подключается через их REST API или готовые Django-пакеты (например, django-paypal). Используем кнопку/редирект на PayPal или API PayPal Checkout. Также обрабатываем IPN/webhook от PayPal, чтобы менять статус заказа.
ЮKassa (бывший Яндекс.Деньги): для РФ. Подключается через библиотеку yookassa или REST API. Конфигурируем секретные ключи и обрабатываем уведомления от сервиса (postbacks), чтобы отметить заказ как оплаченный.
Все платёжные данные (токены, ID транзакций) хранятся в отдельных полях БД (или в модели Payment). После успешной оплаты счёт оплачивается и статус заказа меняется на «оплачен». Для подписок (монетизация) можно использовать подписки Stripe/Braintree.
Уведомления
События (новый заказ, изменение статуса) уведомляют продавца по нескольким каналам:
Email: при поступлении заказа система генерирует письмо с деталями и отправляет на email продавца. Отправка выполняется асинхронно через Celery, чтобы не блокировать запрос. Celery — распределённая очередь задач, позволяющая выполнять «тяжёлые» операции (отправка писем, уведомлений) в фоновом режиме
realpython.com
. Настройка: используем SMTP-сервер или почтовые сервисы (SendGrid, Mailgun) и запускаем задачу Celery (send_order_email.delay(order_id)).
Telegram: при оформлении заказа бот может отправлять уведомление продавцу (на его Telegram-аккаунт). Для этого нужно, чтобы продавец сначала связал свой Telegram (например, сообщил боту свой @username или chat_id). Тогда бот шлёт сообщение «Новый заказ №123 на сумму 1000₽». Отправка тоже через Celery (функция бота вызывается асинхронно) или прямо при создании заказа (если запрос быстрый). Таким образом продавец мгновенно получает оповещение о заказе.
Интеграция с Instagram
Для интеграции с Instagram можно использовать Instagram Graph API (для бизнес-аккаунтов). Возможности:
Публикация товаров в Instagram Shopping: синхронизировать каталог товаров магазина с Instagram и позволить покупателям покупать прямо из приложения. Instagram Shopping API позволяет завести каталог товаров и помечать их на фотографиях. Пользователь видит товар в Instagram и переходит к оформлению у вас.
Автоматический импорт контента: можно подключить бизнес-аккаунт продавца и отображать последние публикации в блоке «Instagram» на лендинге магазина. Это требует запроса к Instagram Basic Display API или Graph API для получения медиа (требуется токен доступа от пользователя).
Аналитика и лиды: с помощью API можно получать статистику по кликам из Instagram и т.д.
API Instagram значительно упрощает интеграцию e-commerce: он «обеспечивает бесшовную интеграцию с e-commerce платформами, позволяя легче демонстрировать товарные каталоги и стимулировать продажи»
pixteller.com
. То есть можно связать магазин и бизнес-аккаунт Instagram, чтобы товары магазина отображались в профиле и покупка шла через ваш сайт.
Монетизация платформы
Платформа может зарабатывать двумя основными способами: абонентская плата и комиссия с продаж. Многие SaaS-компании берут за подписку («разовый/ежемесячный платеж за доступ к сервису»), а также комиссию за обработку платежей или транзакций. Как пишет Stripe, есть два пути монетизации платежей: либо взимать плату с клиентов за оплату (или специальные возможности), либо участвовать в доле с провайдером платежей
stripe.com
. К примеру, можно установить тарифы:
Абонплата: фиксированная месячная/годовая плата за пользование платформой (различные тарифные планы). Чем выше тариф – тем больше функций (больше товаров, транзакций, премиум-функций).
Комиссия: процент от суммы каждого заказа (плата с продавца или с покупателя). Например, Shopify предлагает тарифы + комиссию с каждого заказа, если продавец не использует их собственную платежную систему. Мы можем брать (скажем) 5–10% с каждой успешной продажи на платформе.
Также возможны дополнительные источники: платные фичи (расширенная аналитика, поддержка), реклама или входные билеты за размещение магазина. В моделях онлайн-маркетплейсов обычно выделяют комиссию с транзакции и ежемесячную плату как основные источники дохода
payproglobal.com
. Таким образом, сочетание абонемента и комиссии даёт сбалансированный доход: стабильность по подписке и рост вместе с оборотом продавцов. Источники: подходы к мультиарендности и моделям монетизации описаны, например, в руководствах Django-tenants
django-tenant-schemas.readthedocs.io
testdriven.io
 и Stripe
stripe.com
payproglobal.com
. Преимущества «гостевого» чекаута поддерживаются исследованием Shopify
shopify.com
. Использование Celery для фоновых задач рекомендовано RealPython
realpython.com
. Тренд продаж через чат-боты подтвержден кейсом Crossmint
blog.crossmint.com
. Интеграция с Instagram через API описана в материалах Meta/Stripe
pixteller.com
.